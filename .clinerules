# 重要

ユーザーは Roo よりプログラミングが得意ですが、時短のために Roo にコーディングを依頼しています。

2 回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。

私は GitHub から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速いでしょう。テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。

反面、現在のコンテキストに応じた処理は苦手です。コンテキストが不明瞭な時は、ユーザーに確認します。

## 作業開始準備

`git status` で現在の git のコンテキストを確認します。
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

無視するように言われた場合は、そのまま続行します。

# プロジェクトガイドライン

## ドキュメント要件

- 機能変更時は `/docs` の関連ドキュメントを更新する
- `README.md` は新機能と連携して更新する
- `CHANGELOG.md` に変更履歴を記録する
- アーキテクチャ決定記録（ADR）を `/docs/adr` に保存する：
  - 主要な依存関係の変更
  - アーキテクチャパターンの変更
  - 新しい統合パターン
  - データベーススキーマの変更

## アーキテクチャと設計原則

### 共通原則

- 単一責任の原則を守る
- コンポジションを継承より優先する
- 不変データ構造を使用する
- 副作用を分離する
- 型安全性を確保する
- 関数を優先し、必要な場合のみクラスを使用する

## コードスタイルとパターン

- 関数型アプローチを優先する：
  - `map`、`filter`、`reduce` などを活用する
  - 早期リターンパターンを使用する
- `any` 型の使用を避ける
- 型アサーション `as` の過剰使用を避ける
- 配列型は、シンプルな場合は `T[]` を使い、複雑な場合は `Array<T>` を使う
- モジュールとクラスは単一の目的を持つ
- コード整形・リンティングは保存時に Biome が適用されます。Rooが行う必要はありません
- Valibotは `import * as v from 'valibot';` でインポートして使う

### 型定義のベストプラクティス

```typescript
// Prefer interfaces over type literal aliases
interface User {
  firstName: string;
  lastName: string;
}

// anyの代わりにunknownを使い、型ガードを活用
function processValue(x: unknown): void {
  if (typeof x === 'string') {
    console.log(x.toUpperCase());
  }
}

// 関数の戻り値型を明示
function fetchUser(id: string): Promise<Result<User, ApiError>> {
  // 実装
}
```

## テスト基準

- ビジネスロジックには単体テストを必須とする
- 重要なユーザーフローには E2E テストを実施する
- テストファーストの開発手法を採用する：
  1. 失敗するテストを書く（Red）
  2. テストが通る最小限のコードを実装する（Green）
  3. コードをリファクタリングする（Refactor）
- テスト容易性を設計に組み込む
